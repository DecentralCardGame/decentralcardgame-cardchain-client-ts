// Generated by Ignite ignite.com/cli
import { SigningStargateClient } from "@cosmjs/stargate";
import { Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { Api } from "./rest";
import { MsgRemoveCardFromSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgChangeArtist } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgOpenMatch } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgVoteCard } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgRemoveSellOffer } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgOpenBoosterPack } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSetCardRarity } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgAddCardToSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgAddStoryToSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgTransferCard } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgCreateCouncil } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgBuyCard } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSubmitCopyrightProposal } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgAddContributorToSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgDonateToCard } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSubmitSetProposal } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgTransferBoosterPack } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSetUserBiography } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSetSetName } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgCommitCouncilResponse } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgRegisterForCouncil } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgFinalizeSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSetProfileCard } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgAddArtwork } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSaveCardContent } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgRewokeCouncilRegistration } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSubmitMatchReporterProposal } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgCreateSellOffer } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgCreateuser } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgCreateSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgApointMatchReporter } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSetSetArtist } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgRemoveContributorFromSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgReportMatch } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgRestartCouncil } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSetUserWebsite } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgSetSetStoryWriter } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgMultiVoteCard } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgBuyCardScheme } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgAddArtworkToSet } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgRevealCouncilResponse } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgBuyBoosterPack } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { MsgConfirmMatch } from "./types/DecentralCardGame/cardchain/cardchain/tx";
import { Card as typeCard } from "./types";
import { TimeStamp as typeTimeStamp } from "./types";
import { CopyrightProposal as typeCopyrightProposal } from "./types";
import { WrapClearResponse as typeWrapClearResponse } from "./types";
import { WrapHashResponse as typeWrapHashResponse } from "./types";
import { Image as typeImage } from "./types";
import { MatchPlayer as typeMatchPlayer } from "./types";
import { MatchReporterProposal as typeMatchReporterProposal } from "./types";
import { Num as typeNum } from "./types";
import { Params as typeParams } from "./types";
import { IgnoreMatches as typeIgnoreMatches } from "./types";
import { IgnoreSellOffers as typeIgnoreSellOffers } from "./types";
import { QueryQServerResponse as typeQueryQServerResponse } from "./types";
import { RunningAverage as typeRunningAverage } from "./types";
import { Set as typeSet } from "./types";
import { SetProposal as typeSetProposal } from "./types";
import { BoosterPack as typeBoosterPack } from "./types";
import { AirDrops as typeAirDrops } from "./types";
import { VotingResults as typeVotingResults } from "./types";
import { VotingResult as typeVotingResult } from "./types";
import { SingleVote as typeSingleVote } from "./types";
import { VoteRight as typeVoteRight } from "./types";
export { MsgRemoveCardFromSet, MsgChangeArtist, MsgOpenMatch, MsgVoteCard, MsgRemoveSellOffer, MsgOpenBoosterPack, MsgSetCardRarity, MsgAddCardToSet, MsgAddStoryToSet, MsgTransferCard, MsgCreateCouncil, MsgBuyCard, MsgSubmitCopyrightProposal, MsgAddContributorToSet, MsgDonateToCard, MsgSubmitSetProposal, MsgTransferBoosterPack, MsgSetUserBiography, MsgSetSetName, MsgCommitCouncilResponse, MsgRegisterForCouncil, MsgFinalizeSet, MsgSetProfileCard, MsgAddArtwork, MsgSaveCardContent, MsgRewokeCouncilRegistration, MsgSubmitMatchReporterProposal, MsgCreateSellOffer, MsgCreateuser, MsgCreateSet, MsgApointMatchReporter, MsgSetSetArtist, MsgRemoveContributorFromSet, MsgReportMatch, MsgRestartCouncil, MsgSetUserWebsite, MsgSetSetStoryWriter, MsgMultiVoteCard, MsgBuyCardScheme, MsgAddArtworkToSet, MsgRevealCouncilResponse, MsgBuyBoosterPack, MsgConfirmMatch };
export const registry = new Registry(msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
export const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendMsgRemoveCardFromSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRemoveCardFromSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRemoveCardFromSet({ value: MsgRemoveCardFromSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRemoveCardFromSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChangeArtist({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChangeArtist: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgChangeArtist({ value: MsgChangeArtist.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChangeArtist: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgOpenMatch({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgOpenMatch: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgOpenMatch({ value: MsgOpenMatch.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgOpenMatch: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgVoteCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgVoteCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgVoteCard({ value: MsgVoteCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgVoteCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRemoveSellOffer({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRemoveSellOffer: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRemoveSellOffer({ value: MsgRemoveSellOffer.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRemoveSellOffer: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgOpenBoosterPack({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgOpenBoosterPack: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgOpenBoosterPack({ value: MsgOpenBoosterPack.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgOpenBoosterPack: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetCardRarity({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetCardRarity: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetCardRarity({ value: MsgSetCardRarity.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetCardRarity: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddCardToSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddCardToSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddCardToSet({ value: MsgAddCardToSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddCardToSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddStoryToSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddStoryToSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddStoryToSet({ value: MsgAddStoryToSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddStoryToSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTransferCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTransferCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgTransferCard({ value: MsgTransferCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTransferCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateCouncil({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateCouncil: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateCouncil({ value: MsgCreateCouncil.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateCouncil: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgBuyCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBuyCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgBuyCard({ value: MsgBuyCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBuyCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSubmitCopyrightProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSubmitCopyrightProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSubmitCopyrightProposal({ value: MsgSubmitCopyrightProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSubmitCopyrightProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddContributorToSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddContributorToSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddContributorToSet({ value: MsgAddContributorToSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddContributorToSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgDonateToCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgDonateToCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgDonateToCard({ value: MsgDonateToCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgDonateToCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSubmitSetProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSubmitSetProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSubmitSetProposal({ value: MsgSubmitSetProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSubmitSetProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTransferBoosterPack({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTransferBoosterPack: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgTransferBoosterPack({ value: MsgTransferBoosterPack.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTransferBoosterPack: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetUserBiography({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetUserBiography: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetUserBiography({ value: MsgSetUserBiography.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetUserBiography: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetSetName({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetSetName: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetSetName({ value: MsgSetSetName.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetSetName: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCommitCouncilResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCommitCouncilResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCommitCouncilResponse({ value: MsgCommitCouncilResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCommitCouncilResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRegisterForCouncil({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRegisterForCouncil: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRegisterForCouncil({ value: MsgRegisterForCouncil.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRegisterForCouncil: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgFinalizeSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgFinalizeSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgFinalizeSet({ value: MsgFinalizeSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgFinalizeSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetProfileCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetProfileCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetProfileCard({ value: MsgSetProfileCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetProfileCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddArtwork({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddArtwork: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddArtwork({ value: MsgAddArtwork.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddArtwork: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSaveCardContent({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSaveCardContent: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSaveCardContent({ value: MsgSaveCardContent.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSaveCardContent: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRewokeCouncilRegistration({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRewokeCouncilRegistration: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRewokeCouncilRegistration({ value: MsgRewokeCouncilRegistration.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRewokeCouncilRegistration: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSubmitMatchReporterProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSubmitMatchReporterProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSubmitMatchReporterProposal({ value: MsgSubmitMatchReporterProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSubmitMatchReporterProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateSellOffer({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateSellOffer: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateSellOffer({ value: MsgCreateSellOffer.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateSellOffer: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateuser({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateuser: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateuser({ value: MsgCreateuser.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateuser: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateSet({ value: MsgCreateSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgApointMatchReporter({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgApointMatchReporter: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgApointMatchReporter({ value: MsgApointMatchReporter.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgApointMatchReporter: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetSetArtist({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetSetArtist: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetSetArtist({ value: MsgSetSetArtist.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetSetArtist: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRemoveContributorFromSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRemoveContributorFromSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRemoveContributorFromSet({ value: MsgRemoveContributorFromSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRemoveContributorFromSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgReportMatch({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgReportMatch: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgReportMatch({ value: MsgReportMatch.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgReportMatch: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRestartCouncil({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRestartCouncil: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRestartCouncil({ value: MsgRestartCouncil.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRestartCouncil: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetUserWebsite({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetUserWebsite: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetUserWebsite({ value: MsgSetUserWebsite.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetUserWebsite: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetSetStoryWriter({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetSetStoryWriter: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetSetStoryWriter({ value: MsgSetSetStoryWriter.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetSetStoryWriter: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgMultiVoteCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgMultiVoteCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgMultiVoteCard({ value: MsgMultiVoteCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgMultiVoteCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgBuyCardScheme({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBuyCardScheme: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgBuyCardScheme({ value: MsgBuyCardScheme.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBuyCardScheme: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddArtworkToSet({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddArtworkToSet: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddArtworkToSet({ value: MsgAddArtworkToSet.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddArtworkToSet: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRevealCouncilResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRevealCouncilResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRevealCouncilResponse({ value: MsgRevealCouncilResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRevealCouncilResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgBuyBoosterPack({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBuyBoosterPack: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgBuyBoosterPack({ value: MsgBuyBoosterPack.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBuyBoosterPack: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgConfirmMatch({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgConfirmMatch: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgConfirmMatch({ value: MsgConfirmMatch.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgConfirmMatch: Could not broadcast Tx: ' + e.message);
            }
        },
        msgRemoveCardFromSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRemoveCardFromSet", value: MsgRemoveCardFromSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRemoveCardFromSet: Could not create message: ' + e.message);
            }
        },
        msgChangeArtist({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgChangeArtist", value: MsgChangeArtist.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChangeArtist: Could not create message: ' + e.message);
            }
        },
        msgOpenMatch({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgOpenMatch", value: MsgOpenMatch.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgOpenMatch: Could not create message: ' + e.message);
            }
        },
        msgVoteCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgVoteCard", value: MsgVoteCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgVoteCard: Could not create message: ' + e.message);
            }
        },
        msgRemoveSellOffer({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRemoveSellOffer", value: MsgRemoveSellOffer.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRemoveSellOffer: Could not create message: ' + e.message);
            }
        },
        msgOpenBoosterPack({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgOpenBoosterPack", value: MsgOpenBoosterPack.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgOpenBoosterPack: Could not create message: ' + e.message);
            }
        },
        msgSetCardRarity({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetCardRarity", value: MsgSetCardRarity.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetCardRarity: Could not create message: ' + e.message);
            }
        },
        msgAddCardToSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddCardToSet", value: MsgAddCardToSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddCardToSet: Could not create message: ' + e.message);
            }
        },
        msgAddStoryToSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddStoryToSet", value: MsgAddStoryToSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddStoryToSet: Could not create message: ' + e.message);
            }
        },
        msgTransferCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgTransferCard", value: MsgTransferCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTransferCard: Could not create message: ' + e.message);
            }
        },
        msgCreateCouncil({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateCouncil", value: MsgCreateCouncil.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateCouncil: Could not create message: ' + e.message);
            }
        },
        msgBuyCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgBuyCard", value: MsgBuyCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBuyCard: Could not create message: ' + e.message);
            }
        },
        msgSubmitCopyrightProposal({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSubmitCopyrightProposal", value: MsgSubmitCopyrightProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSubmitCopyrightProposal: Could not create message: ' + e.message);
            }
        },
        msgAddContributorToSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddContributorToSet", value: MsgAddContributorToSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddContributorToSet: Could not create message: ' + e.message);
            }
        },
        msgDonateToCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgDonateToCard", value: MsgDonateToCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgDonateToCard: Could not create message: ' + e.message);
            }
        },
        msgSubmitSetProposal({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSubmitSetProposal", value: MsgSubmitSetProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSubmitSetProposal: Could not create message: ' + e.message);
            }
        },
        msgTransferBoosterPack({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgTransferBoosterPack", value: MsgTransferBoosterPack.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTransferBoosterPack: Could not create message: ' + e.message);
            }
        },
        msgSetUserBiography({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetUserBiography", value: MsgSetUserBiography.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetUserBiography: Could not create message: ' + e.message);
            }
        },
        msgSetSetName({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetSetName", value: MsgSetSetName.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetSetName: Could not create message: ' + e.message);
            }
        },
        msgCommitCouncilResponse({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCommitCouncilResponse", value: MsgCommitCouncilResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCommitCouncilResponse: Could not create message: ' + e.message);
            }
        },
        msgRegisterForCouncil({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRegisterForCouncil", value: MsgRegisterForCouncil.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRegisterForCouncil: Could not create message: ' + e.message);
            }
        },
        msgFinalizeSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgFinalizeSet", value: MsgFinalizeSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgFinalizeSet: Could not create message: ' + e.message);
            }
        },
        msgSetProfileCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetProfileCard", value: MsgSetProfileCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetProfileCard: Could not create message: ' + e.message);
            }
        },
        msgAddArtwork({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddArtwork", value: MsgAddArtwork.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddArtwork: Could not create message: ' + e.message);
            }
        },
        msgSaveCardContent({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSaveCardContent", value: MsgSaveCardContent.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSaveCardContent: Could not create message: ' + e.message);
            }
        },
        msgRewokeCouncilRegistration({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRewokeCouncilRegistration", value: MsgRewokeCouncilRegistration.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRewokeCouncilRegistration: Could not create message: ' + e.message);
            }
        },
        msgSubmitMatchReporterProposal({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSubmitMatchReporterProposal", value: MsgSubmitMatchReporterProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSubmitMatchReporterProposal: Could not create message: ' + e.message);
            }
        },
        msgCreateSellOffer({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateSellOffer", value: MsgCreateSellOffer.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateSellOffer: Could not create message: ' + e.message);
            }
        },
        msgCreateuser({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateuser", value: MsgCreateuser.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateuser: Could not create message: ' + e.message);
            }
        },
        msgCreateSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateSet", value: MsgCreateSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateSet: Could not create message: ' + e.message);
            }
        },
        msgApointMatchReporter({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgApointMatchReporter", value: MsgApointMatchReporter.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgApointMatchReporter: Could not create message: ' + e.message);
            }
        },
        msgSetSetArtist({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetSetArtist", value: MsgSetSetArtist.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetSetArtist: Could not create message: ' + e.message);
            }
        },
        msgRemoveContributorFromSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRemoveContributorFromSet", value: MsgRemoveContributorFromSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRemoveContributorFromSet: Could not create message: ' + e.message);
            }
        },
        msgReportMatch({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgReportMatch", value: MsgReportMatch.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgReportMatch: Could not create message: ' + e.message);
            }
        },
        msgRestartCouncil({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRestartCouncil", value: MsgRestartCouncil.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRestartCouncil: Could not create message: ' + e.message);
            }
        },
        msgSetUserWebsite({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetUserWebsite", value: MsgSetUserWebsite.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetUserWebsite: Could not create message: ' + e.message);
            }
        },
        msgSetSetStoryWriter({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetSetStoryWriter", value: MsgSetSetStoryWriter.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetSetStoryWriter: Could not create message: ' + e.message);
            }
        },
        msgMultiVoteCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgMultiVoteCard", value: MsgMultiVoteCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgMultiVoteCard: Could not create message: ' + e.message);
            }
        },
        msgBuyCardScheme({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgBuyCardScheme", value: MsgBuyCardScheme.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBuyCardScheme: Could not create message: ' + e.message);
            }
        },
        msgAddArtworkToSet({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddArtworkToSet", value: MsgAddArtworkToSet.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddArtworkToSet: Could not create message: ' + e.message);
            }
        },
        msgRevealCouncilResponse({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRevealCouncilResponse", value: MsgRevealCouncilResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRevealCouncilResponse: Could not create message: ' + e.message);
            }
        },
        msgBuyBoosterPack({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgBuyBoosterPack", value: MsgBuyBoosterPack.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBuyBoosterPack: Could not create message: ' + e.message);
            }
        },
        msgConfirmMatch({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgConfirmMatch", value: MsgConfirmMatch.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgConfirmMatch: Could not create message: ' + e.message);
            }
        },
    };
};
export const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new Api({ baseURL: addr });
};
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = queryClient({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {
            Card: getStructure(typeCard.fromPartial({})),
            TimeStamp: getStructure(typeTimeStamp.fromPartial({})),
            CopyrightProposal: getStructure(typeCopyrightProposal.fromPartial({})),
            WrapClearResponse: getStructure(typeWrapClearResponse.fromPartial({})),
            WrapHashResponse: getStructure(typeWrapHashResponse.fromPartial({})),
            Image: getStructure(typeImage.fromPartial({})),
            MatchPlayer: getStructure(typeMatchPlayer.fromPartial({})),
            MatchReporterProposal: getStructure(typeMatchReporterProposal.fromPartial({})),
            Num: getStructure(typeNum.fromPartial({})),
            Params: getStructure(typeParams.fromPartial({})),
            IgnoreMatches: getStructure(typeIgnoreMatches.fromPartial({})),
            IgnoreSellOffers: getStructure(typeIgnoreSellOffers.fromPartial({})),
            QueryQServerResponse: getStructure(typeQueryQServerResponse.fromPartial({})),
            RunningAverage: getStructure(typeRunningAverage.fromPartial({})),
            Set: getStructure(typeSet.fromPartial({})),
            SetProposal: getStructure(typeSetProposal.fromPartial({})),
            BoosterPack: getStructure(typeBoosterPack.fromPartial({})),
            AirDrops: getStructure(typeAirDrops.fromPartial({})),
            VotingResults: getStructure(typeVotingResults.fromPartial({})),
            VotingResult: getStructure(typeVotingResult.fromPartial({})),
            SingleVote: getStructure(typeSingleVote.fromPartial({})),
            VoteRight: getStructure(typeVoteRight.fromPartial({})),
        };
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = txClient({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const Module = (test) => {
    return {
        module: {
            DecentralCardGameCardchainCardchain: new SDKModule(test)
        },
        registry: msgTypes
    };
};
export default Module;
